---
// background-graphics.astro
import { cms, site } from "@/utils/constants";
import fetchBackgroundGraphics from "@/utils/backgroundfetch";

const backgroundGraphics = await fetchBackgroundGraphics();
---

<div class="absolute inset-0 -z-10 overflow-hidden">
  <!-- Gradient background -->
  <div class="absolute inset-0 bg-gradient-to-br from-green-100 via-amber-50 to-white"></div>

  <!-- Organic blobs -->
  <svg class="absolute -top-40 -left-40 w-[600px] h-[600px] opacity-30 blur-3xl" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
    <path fill="#86efac" d="M40.5,-70.2C52.8,-63.9,63.6,-52.8,71.4,-39.4C79.1,-26,83.8,-10.3,81.7,4.3C79.5,18.8,70.5,31.9,59.4,42.6C48.4,53.3,35.3,61.7,20.5,67.3C5.8,72.9,-10.5,75.6,-25.1,71.1C-39.7,66.7,-52.7,55.2,-62.3,41.3C-71.9,27.3,-78,11,-75.2,-4.9C-72.3,-20.8,-60.4,-36.3,-46.5,-44.9C-32.7,-53.6,-16.3,-55.4,-0.6,-54.6C15.1,-53.8,30.2,-50.4,40.5,-70.2Z" transform="translate(100 100)" />
  </svg>

  <svg class="absolute bottom-0 right-0 w-[400px] h-[400px] opacity-20 blur-2xl" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
    <path fill="#fde68a" d="M42.7,-73.7C54.6,-66.2,62.9,-54.3,69.2,-41.7C75.5,-29.1,79.8,-15.9,77.4,-3.4C75,-9.2,65.7,7.7,59.8,21.7C54,35.7,51.5,47,43.1,56.7C34.7,66.5,20.4,74.6,5.8,70.7C-8.9,66.8,-17.8,50.8,-29,39.3C-40.2,27.7,-53.7,20.7,-60.7,8.8C-67.7,-3.1,-68.2,-20,-62.4,-35.7C-56.5,-51.4,-44.4,-66,-30.3,-72.1C-16.1,-78.2,-0.8,-75.8,13.9,-72.7C28.7,-69.7,42.7,-66.2,42.7,-73.7Z" transform="translate(100 100)" />
  </svg>
</div>
<!-- <div id="background-container" class="fixed inset-0 -z-10"></div> -->
<div id="background-container" class="relative w-full -z-10"></div>

<script type="module" define:vars={{backgroundGraphics}} is:inline>
  let offset = Math.round(Math.random())
  function isMobile() {
      return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|Windows Phone|Opera Mini/i.test(navigator.userAgent);
  }
  function clearContainer(container) {
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
  }
  function getScalingFactor(minWidth = 320, maxWidth = 1700, minScale = 0.75, maxScale = 1.0) {
    const clampedWidth = Math.min(Math.max(window.innerWidth, minWidth), maxWidth);
    const scale =
      ((clampedWidth - minWidth) / (maxWidth - minWidth)) * (maxScale - minScale) + minScale;
    console.log(scale)
    return scale;
  }

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  async function downloadImage(url) {
    try {
      // Fetch the image from the URL
      const response = await fetch(url);
      
      // Check if the response is ok
      if (!response.ok) {
        throw new Error('Image failed to load');
      }

      // Get the Blob from the response
      const blob = await response.blob();

      // Convert the Blob to a Data URL using FileReader wrapped in a Promise
      const base64Data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = () => reject('Failed to read Blob');
        
        reader.readAsDataURL(blob);
      });

      return base64Data;
    } catch (err) {
      throw new Error(`Failed to download image: ${err.message}`);
    }
  }

  async function createImagesInHTML(graphics) {
    const container = document.getElementById('background-container');
    if (!container) {
      console.warn('❌ Container not found!');
      return;
    }

    clearContainer(container);

    const scalingFactor = getScalingFactor();
    const imageSize = 200 * scalingFactor;
    const spacing = 80 * scalingFactor;

    const banner = document.getElementById("frontpage-banner-bg");
    let reservedH = 30;
    if (banner && window.innerWidth < 1300) {
      reservedH = banner.getBoundingClientRect().height + reservedH;
    }

    const height = Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight,
      document.body.offsetHeight,
      document.documentElement.offsetHeight,
      document.body.clientHeight,
      document.documentElement.clientHeight
    ) * 0.95 - reservedH;

    const numberOfItems = Math.floor(height / (imageSize + spacing));
    const slicedArray = shuffleArray(graphics).slice(0, numberOfItems);

    let spacingHeight = height / slicedArray.length;
    let spacingBetween = spacingHeight - imageSize;
    offset ^= 1;

    // Use for...of loop to handle async operations
    for (const [index, graphic] of slicedArray.entries()) {
      const filename = graphic.url.split('/').pop();
      const key = `image_${filename}`;
      let base64Data = localStorage.getItem(key);

      if (!base64Data) {
        try {
          base64Data = await downloadImage(graphic.url);
          localStorage.setItem(`image_${filename}`, base64Data); // Fixed variable name
        } catch (err) {
          console.error(`❌ Failed to download image: ${graphic.url}`, err);
          continue; // Skip to the next iteration if download fails
        }
      }

      const imageId = `image-${index}`;
      const sizeVariation = Math.random() * 50;
      const finalSize = imageSize + sizeVariation;

      const verticalPosition = index * (imageSize + spacingBetween) + reservedH;

      const isLeft = index % 2 === offset;
      const horizontalPosition = isLeft
        ? '9%'
        : `calc(95% - ${Math.round(300 * scalingFactor)}px)`;

      const img = document.createElement('img');
      img.src = base64Data;
      img.id = imageId;
      img.classList.add(
        'absolute',
        'mix-blend-screen',
        'drop-shadow-lg',
        'saturate-150',
        'contrast-125'
      );
     
      img.style.cssText = `
        top: ${verticalPosition}px;
        left: ${horizontalPosition};
        width: ${finalSize * scalingFactor}px;
        height: ${finalSize * scalingFactor}px;
        object-fit: contain;
        pointer-events: none;
        opacity: 0;
        transform:  rotate(0deg) scale(1);
        transition: transform 0.7s ease, opacity 0.7s ease;
      `;

      container.appendChild(img);

      // Trigger reflow to ensure styles are applied before animation starts
      img.getBoundingClientRect();
      img.style.transform = `translateX(${isLeft ? '-25%' : '25%'}) rotate(${Math.random() * 20 - 10}deg) scale(${Math.random() * 0.2 + 0.9})`;
    
      img.style.opacity = '0.75';
    }
  }


  function startAutoShuffle() {
    createImagesInHTML(backgroundGraphics);
    setInterval(() => {
      createImagesInHTML(backgroundGraphics);
    }, 9500);
  }

  // Wait for images to be stored, then start shuffle after page load
    window.addEventListener("load", () => {
      startAutoShuffle(); 
    });
</script>